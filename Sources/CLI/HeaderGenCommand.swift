//
//  HeaderGenCommand.swift
//  GRPH CLI
// 
//  Created by Emil Pedersen on 28/01/2022.
//  Copyright Â© 2020 Snowy_1803. All rights reserved.
// 
//  This Source Code Form is subject to the terms of the Mozilla Public
//  License, v. 2.0. If a copy of the MPL was not distributed with this
//  file, You can obtain one at https://mozilla.org/MPL/2.0/.
//

import Foundation
import ArgumentParser
import GRPHValues
import GRPHRuntime

struct HeaderGenCommand: ParsableCommand {
    
    static var configuration: CommandConfiguration {
        CommandConfiguration(commandName: "gen-header", abstract: "Generate a namespace C header file", shouldDisplay: false)
    }
    
    @Argument(help: "The namespace name to generate a header for")
    var namespace: String
    
    func run() throws {
        guard let ns = NameSpaces.namespace(named: namespace) else {
            print("Namespace not found")
            throw ExitCode.failure
        }
        
        print("""
            //
            //  \(ns.name).h
            //  GRPH stdlib - libgrph
            //
            //  Autogenerated by `grph gen-header \(ns.name)`.
            //
            //  This Source Code Form is subject to the terms of the Mozilla Public
            //  License, v. 2.0. If a copy of the MPL was not distributed with this
            //  file, You can obtain one at https://mozilla.org/MPL/2.0/.
            //

            #ifndef GRPH_NS_\(ns.name.uppercased())_H
            #define GRPH_NS_\(ns.name.uppercased())_H
            
            #include "grph_types.h"
            #include "grph_shapes.h"

            """)
        
        for fn in ns.exportedFunctions {
            guard let rt = fn.returnType.getNameInC(asReturnType: true),
                  !fn.varargs,
                  let params = fn.parameters.map({ par -> String? in
                      guard let t = (par.optional ? par.type.optional : par.type).getNameInC(asReturnType: false) else {
                          return nil
                      }
                      return "\(t) \(par.name == "char" ? "character" : par.name)"
                  }).reduce(into: [] as [String]?, { into, curr in
                      if let curr = curr {
                          into?.append(curr)
                      } else {
                          into = nil
                      }
                  }) else {
                printerr("Function \(fn.name) cannot yet be represented")
                continue
            }
            print("\(rt) \(fn.getMangledName(generator: nil))(\(params.isEmpty ? "void" : params.joined(separator: ", ")));")
        }
        
        print("""
            
            #endif /* GRPH_NS_\(ns.name.uppercased())_H */
            
            """)
    }
}

extension GRPHType {
    func getNameInC(asReturnType: Bool) -> String? {
        switch self {
        case let self as SimpleType:
            switch self {
            case SimpleType.void:
                return asReturnType ? "void" : "grph_void_t"
            case .integer, .float, .rotation, .boolean, .pos, .string, .Background, .Group:
                return "grph_\(self.string)_t"
            case .mixed, .paint, .num, .funcref:
                return "struct grph_existential *"
            case .shape:
                return "grph_shape_t *"
            default:
                return nil
            }
        case let self as OptionalType:
            if let wrapped = self.wrapped.getNameInC(asReturnType: false) {
                if wrapped.contains("*") {
                    return nil
                }
                return "optional_\(wrapped.dropFirst(5))"
            } else {
                return nil
            }
        default:
            return nil
        }
    }
}
